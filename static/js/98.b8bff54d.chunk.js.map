{"version":3,"file":"static/js/98.b8bff54d.chunk.js","mappings":"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","sources":["../node_modules/graphql/jsutils/invariant.mjs","../node_modules/graphql/language/location.mjs","../node_modules/graphql/language/printLocation.mjs","../node_modules/graphql/error/GraphQLError.mjs","../node_modules/graphql/jsutils/isObjectLike.mjs","../node_modules/graphql/error/syntaxError.mjs","../node_modules/graphql/language/directiveLocation.mjs","../node_modules/graphql/language/tokenKind.mjs","../node_modules/graphql/language/lexer.mjs","../node_modules/graphql/language/parser.mjs","../node_modules/graphql-tag/src/index.ts","../node_modules/@apollo/src/react/hooks/useApolloClient.ts","../node_modules/@apollo/src/react/hooks/useMutation.ts","../node_modules/@apollo/src/react/hooks/useSyncExternalStore.ts","../node_modules/@apollo/src/react/hooks/useQuery.ts","../node_modules/@apollo/src/react/parser/index.ts"],"sourcesContent":["export function invariant(condition, message) {\n  const booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(\n      message != null ? message : 'Unexpected invariant triggered.',\n    );\n  }\n}\n","import { invariant } from '../jsutils/invariant.mjs';\nconst LineRegExp = /\\r\\n|[\\n\\r]/g;\n/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport function getLocation(source, position) {\n  let lastLineStart = 0;\n  let line = 1;\n\n  for (const match of source.body.matchAll(LineRegExp)) {\n    typeof match.index === 'number' || invariant(false);\n\n    if (match.index >= position) {\n      break;\n    }\n\n    lastLineStart = match.index + match[0].length;\n    line += 1;\n  }\n\n  return {\n    line,\n    column: position + 1 - lastLineStart,\n  };\n}\n","import { getLocation } from './location.mjs';\n\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\nexport function printLocation(location) {\n  return printSourceLocation(\n    location.source,\n    getLocation(location.source, location.start),\n  );\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printSourceLocation(source, sourceLocation) {\n  const firstLineColumnOffset = source.locationOffset.column - 1;\n  const body = ''.padStart(firstLineColumnOffset) + source.body;\n  const lineIndex = sourceLocation.line - 1;\n  const lineOffset = source.locationOffset.line - 1;\n  const lineNum = sourceLocation.line + lineOffset;\n  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  const columnNum = sourceLocation.column + columnOffset;\n  const locationStr = `${source.name}:${lineNum}:${columnNum}\\n`;\n  const lines = body.split(/\\r\\n|[\\n\\r]/g);\n  const locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    const subLineIndex = Math.floor(columnNum / 80);\n    const subLineColumnNum = columnNum % 80;\n    const subLines = [];\n\n    for (let i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n\n    return (\n      locationStr +\n      printPrefixedLines([\n        [`${lineNum} |`, subLines[0]],\n        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ['|', subLine]),\n        ['|', '^'.padStart(subLineColumnNum)],\n        ['|', subLines[subLineIndex + 1]],\n      ])\n    );\n  }\n\n  return (\n    locationStr +\n    printPrefixedLines([\n      // Lines specified like this: [\"prefix\", \"string\"],\n      [`${lineNum - 1} |`, lines[lineIndex - 1]],\n      [`${lineNum} |`, locationLine],\n      ['|', '^'.padStart(columnNum)],\n      [`${lineNum + 1} |`, lines[lineIndex + 1]],\n    ])\n  );\n}\n\nfunction printPrefixedLines(lines) {\n  const existingLines = lines.filter(([_, line]) => line !== undefined);\n  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));\n  return existingLines\n    .map(([prefix, line]) => prefix.padStart(padLen) + (line ? ' ' + line : ''))\n    .join('\\n');\n}\n","import { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { getLocation } from '../language/location.mjs';\nimport {\n  printLocation,\n  printSourceLocation,\n} from '../language/printLocation.mjs';\n\nfunction toNormalizedOptions(args) {\n  const firstArg = args[0];\n\n  if (firstArg == null || 'kind' in firstArg || 'length' in firstArg) {\n    return {\n      nodes: firstArg,\n      source: args[1],\n      positions: args[2],\n      path: args[3],\n      originalError: args[4],\n      extensions: args[5],\n    };\n  }\n\n  return firstArg;\n}\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nexport class GraphQLError extends Error {\n  /**\n   * An array of `{ line, column }` locations within the source GraphQL document\n   * which correspond to this error.\n   *\n   * Errors during validation often contain multiple locations, for example to\n   * point out two things with the same name. Errors during execution include a\n   * single location, the field which produced the error.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array describing the JSON-path into the execution response which\n   * corresponds to this error. Only included for errors during execution.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array of GraphQL AST Nodes corresponding to this error.\n   */\n\n  /**\n   * The source GraphQL document for the first location of this error.\n   *\n   * Note that if this Error represents more than one node, the source may not\n   * represent nodes after the first node.\n   */\n\n  /**\n   * An array of character offsets within the source GraphQL document\n   * which correspond to this error.\n   */\n\n  /**\n   * The original error thrown from a field resolver during execution.\n   */\n\n  /**\n   * Extension fields to add to the formatted error.\n   */\n\n  /**\n   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.\n   */\n  constructor(message, ...rawArgs) {\n    var _this$nodes, _nodeLocations$, _ref;\n\n    const { nodes, source, positions, path, originalError, extensions } =\n      toNormalizedOptions(rawArgs);\n    super(message);\n    this.name = 'GraphQLError';\n    this.path = path !== null && path !== void 0 ? path : undefined;\n    this.originalError =\n      originalError !== null && originalError !== void 0\n        ? originalError\n        : undefined; // Compute list of blame nodes.\n\n    this.nodes = undefinedIfEmpty(\n      Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined,\n    );\n    const nodeLocations = undefinedIfEmpty(\n      (_this$nodes = this.nodes) === null || _this$nodes === void 0\n        ? void 0\n        : _this$nodes.map((node) => node.loc).filter((loc) => loc != null),\n    ); // Compute locations in the source for the given nodes/positions.\n\n    this.source =\n      source !== null && source !== void 0\n        ? source\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : (_nodeLocations$ = nodeLocations[0]) === null ||\n          _nodeLocations$ === void 0\n        ? void 0\n        : _nodeLocations$.source;\n    this.positions =\n      positions !== null && positions !== void 0\n        ? positions\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => loc.start);\n    this.locations =\n      positions && source\n        ? positions.map((pos) => getLocation(source, pos))\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => getLocation(loc.source, loc.start));\n    const originalExtensions = isObjectLike(\n      originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions,\n    )\n      ? originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions\n      : undefined;\n    this.extensions =\n      (_ref =\n        extensions !== null && extensions !== void 0\n          ? extensions\n          : originalExtensions) !== null && _ref !== void 0\n        ? _ref\n        : Object.create(null); // Only properties prescribed by the spec should be enumerable.\n    // Keep the rest as non-enumerable.\n\n    Object.defineProperties(this, {\n      message: {\n        writable: true,\n        enumerable: true,\n      },\n      name: {\n        enumerable: false,\n      },\n      nodes: {\n        enumerable: false,\n      },\n      source: {\n        enumerable: false,\n      },\n      positions: {\n        enumerable: false,\n      },\n      originalError: {\n        enumerable: false,\n      },\n    }); // Include (non-enumerable) stack trace.\n\n    /* c8 ignore start */\n    // FIXME: https://github.com/graphql/graphql-js/issues/2317\n\n    if (\n      originalError !== null &&\n      originalError !== void 0 &&\n      originalError.stack\n    ) {\n      Object.defineProperty(this, 'stack', {\n        value: originalError.stack,\n        writable: true,\n        configurable: true,\n      });\n    } else if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, GraphQLError);\n    } else {\n      Object.defineProperty(this, 'stack', {\n        value: Error().stack,\n        writable: true,\n        configurable: true,\n      });\n    }\n    /* c8 ignore stop */\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLError';\n  }\n\n  toString() {\n    let output = this.message;\n\n    if (this.nodes) {\n      for (const node of this.nodes) {\n        if (node.loc) {\n          output += '\\n\\n' + printLocation(node.loc);\n        }\n      }\n    } else if (this.source && this.locations) {\n      for (const location of this.locations) {\n        output += '\\n\\n' + printSourceLocation(this.source, location);\n      }\n    }\n\n    return output;\n  }\n\n  toJSON() {\n    const formattedError = {\n      message: this.message,\n    };\n\n    if (this.locations != null) {\n      formattedError.locations = this.locations;\n    }\n\n    if (this.path != null) {\n      formattedError.path = this.path;\n    }\n\n    if (this.extensions != null && Object.keys(this.extensions).length > 0) {\n      formattedError.extensions = this.extensions;\n    }\n\n    return formattedError;\n  }\n}\n\nfunction undefinedIfEmpty(array) {\n  return array === undefined || array.length === 0 ? undefined : array;\n}\n/**\n * See: https://spec.graphql.org/draft/#sec-Errors\n */\n\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n *\n * @deprecated Please use `error.toString` instead. Will be removed in v17\n */\nexport function printError(error) {\n  return error.toString();\n}\n/**\n * Given a GraphQLError, format it according to the rules described by the\n * Response Format, Errors section of the GraphQL Specification.\n *\n * @deprecated Please use `error.toJSON` instead. Will be removed in v17\n */\n\nexport function formatError(error) {\n  return error.toJSON();\n}\n","/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nexport function isObjectLike(value) {\n  return typeof value == 'object' && value !== null;\n}\n","import { GraphQLError } from './GraphQLError.mjs';\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nexport function syntaxError(source, position, description) {\n  return new GraphQLError(`Syntax Error: ${description}`, {\n    source,\n    positions: [position],\n  });\n}\n","/**\n * The set of allowed directive location values.\n */\nvar DirectiveLocation;\n\n(function (DirectiveLocation) {\n  DirectiveLocation['QUERY'] = 'QUERY';\n  DirectiveLocation['MUTATION'] = 'MUTATION';\n  DirectiveLocation['SUBSCRIPTION'] = 'SUBSCRIPTION';\n  DirectiveLocation['FIELD'] = 'FIELD';\n  DirectiveLocation['FRAGMENT_DEFINITION'] = 'FRAGMENT_DEFINITION';\n  DirectiveLocation['FRAGMENT_SPREAD'] = 'FRAGMENT_SPREAD';\n  DirectiveLocation['INLINE_FRAGMENT'] = 'INLINE_FRAGMENT';\n  DirectiveLocation['VARIABLE_DEFINITION'] = 'VARIABLE_DEFINITION';\n  DirectiveLocation['SCHEMA'] = 'SCHEMA';\n  DirectiveLocation['SCALAR'] = 'SCALAR';\n  DirectiveLocation['OBJECT'] = 'OBJECT';\n  DirectiveLocation['FIELD_DEFINITION'] = 'FIELD_DEFINITION';\n  DirectiveLocation['ARGUMENT_DEFINITION'] = 'ARGUMENT_DEFINITION';\n  DirectiveLocation['INTERFACE'] = 'INTERFACE';\n  DirectiveLocation['UNION'] = 'UNION';\n  DirectiveLocation['ENUM'] = 'ENUM';\n  DirectiveLocation['ENUM_VALUE'] = 'ENUM_VALUE';\n  DirectiveLocation['INPUT_OBJECT'] = 'INPUT_OBJECT';\n  DirectiveLocation['INPUT_FIELD_DEFINITION'] = 'INPUT_FIELD_DEFINITION';\n})(DirectiveLocation || (DirectiveLocation = {}));\n\nexport { DirectiveLocation };\n/**\n * The enum type representing the directive location values.\n *\n * @deprecated Please use `DirectiveLocation`. Will be remove in v17.\n */\n","/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nvar TokenKind;\n\n(function (TokenKind) {\n  TokenKind['SOF'] = '<SOF>';\n  TokenKind['EOF'] = '<EOF>';\n  TokenKind['BANG'] = '!';\n  TokenKind['DOLLAR'] = '$';\n  TokenKind['AMP'] = '&';\n  TokenKind['PAREN_L'] = '(';\n  TokenKind['PAREN_R'] = ')';\n  TokenKind['SPREAD'] = '...';\n  TokenKind['COLON'] = ':';\n  TokenKind['EQUALS'] = '=';\n  TokenKind['AT'] = '@';\n  TokenKind['BRACKET_L'] = '[';\n  TokenKind['BRACKET_R'] = ']';\n  TokenKind['BRACE_L'] = '{';\n  TokenKind['PIPE'] = '|';\n  TokenKind['BRACE_R'] = '}';\n  TokenKind['NAME'] = 'Name';\n  TokenKind['INT'] = 'Int';\n  TokenKind['FLOAT'] = 'Float';\n  TokenKind['STRING'] = 'String';\n  TokenKind['BLOCK_STRING'] = 'BlockString';\n  TokenKind['COMMENT'] = 'Comment';\n})(TokenKind || (TokenKind = {}));\n\nexport { TokenKind };\n/**\n * The enum type representing the token kinds values.\n *\n * @deprecated Please use `TokenKind`. Will be remove in v17.\n */\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Token } from './ast.mjs';\nimport { dedentBlockStringLines } from './blockString.mjs';\nimport { isDigit, isNameContinue, isNameStart } from './characterClasses.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nexport class Lexer {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  constructor(source) {\n    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Lexer';\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n  advance() {\n    this.lastToken = this.token;\n    const token = (this.token = this.lookahead());\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n\n  lookahead() {\n    let token = this.token;\n\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        if (token.next) {\n          token = token.next;\n        } else {\n          // Read the next token and form a link in the token linked-list.\n          const nextToken = readNextToken(this, token.end); // @ts-expect-error next is only mutable during parsing.\n\n          token.next = nextToken; // @ts-expect-error prev is only mutable during parsing.\n\n          nextToken.prev = token;\n          token = nextToken;\n        }\n      } while (token.kind === TokenKind.COMMENT);\n    }\n\n    return token;\n  }\n}\n/**\n * @internal\n */\n\nexport function isPunctuatorTokenKind(kind) {\n  return (\n    kind === TokenKind.BANG ||\n    kind === TokenKind.DOLLAR ||\n    kind === TokenKind.AMP ||\n    kind === TokenKind.PAREN_L ||\n    kind === TokenKind.PAREN_R ||\n    kind === TokenKind.SPREAD ||\n    kind === TokenKind.COLON ||\n    kind === TokenKind.EQUALS ||\n    kind === TokenKind.AT ||\n    kind === TokenKind.BRACKET_L ||\n    kind === TokenKind.BRACKET_R ||\n    kind === TokenKind.BRACE_L ||\n    kind === TokenKind.PIPE ||\n    kind === TokenKind.BRACE_R\n  );\n}\n/**\n * A Unicode scalar value is any Unicode code point except surrogate code\n * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and\n * 0xE000 to 0x10FFFF.\n *\n * SourceCharacter ::\n *   - \"Any Unicode scalar value\"\n */\n\nfunction isUnicodeScalarValue(code) {\n  return (\n    (code >= 0x0000 && code <= 0xd7ff) || (code >= 0xe000 && code <= 0x10ffff)\n  );\n}\n/**\n * The GraphQL specification defines source text as a sequence of unicode scalar\n * values (which Unicode defines to exclude surrogate code points). However\n * JavaScript defines strings as a sequence of UTF-16 code units which may\n * include surrogates. A surrogate pair is a valid source character as it\n * encodes a supplementary code point (above U+FFFF), but unpaired surrogate\n * code points are not valid source characters.\n */\n\nfunction isSupplementaryCodePoint(body, location) {\n  return (\n    isLeadingSurrogate(body.charCodeAt(location)) &&\n    isTrailingSurrogate(body.charCodeAt(location + 1))\n  );\n}\n\nfunction isLeadingSurrogate(code) {\n  return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction isTrailingSurrogate(code) {\n  return code >= 0xdc00 && code <= 0xdfff;\n}\n/**\n * Prints the code point (or end of file reference) at a given location in a\n * source for use in error messages.\n *\n * Printable ASCII is printed quoted, while other points are printed in Unicode\n * code point form (ie. U+1234).\n */\n\nfunction printCodePointAt(lexer, location) {\n  const code = lexer.source.body.codePointAt(location);\n\n  if (code === undefined) {\n    return TokenKind.EOF;\n  } else if (code >= 0x0020 && code <= 0x007e) {\n    // Printable ASCII\n    const char = String.fromCodePoint(code);\n    return char === '\"' ? \"'\\\"'\" : `\"${char}\"`;\n  } // Unicode code point\n\n  return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\n}\n/**\n * Create a token with line and column location information.\n */\n\nfunction createToken(lexer, kind, start, end, value) {\n  const line = lexer.line;\n  const col = 1 + start - lexer.lineStart;\n  return new Token(kind, start, end, line, col, value);\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\nfunction readNextToken(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // SourceCharacter\n\n    switch (code) {\n      // Ignored ::\n      //   - UnicodeBOM\n      //   - WhiteSpace\n      //   - LineTerminator\n      //   - Comment\n      //   - Comma\n      //\n      // UnicodeBOM :: \"Byte Order Mark (U+FEFF)\"\n      //\n      // WhiteSpace ::\n      //   - \"Horizontal Tab (U+0009)\"\n      //   - \"Space (U+0020)\"\n      //\n      // Comma :: ,\n      case 0xfeff: // <BOM>\n\n      case 0x0009: // \\t\n\n      case 0x0020: // <space>\n\n      case 0x002c:\n        // ,\n        ++position;\n        continue;\n      // LineTerminator ::\n      //   - \"New Line (U+000A)\"\n      //   - \"Carriage Return (U+000D)\" [lookahead != \"New Line (U+000A)\"]\n      //   - \"Carriage Return (U+000D)\" \"New Line (U+000A)\"\n\n      case 0x000a:\n        // \\n\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n\n      case 0x000d:\n        // \\r\n        if (body.charCodeAt(position + 1) === 0x000a) {\n          position += 2;\n        } else {\n          ++position;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      // Comment\n\n      case 0x0023:\n        // #\n        return readComment(lexer, position);\n      // Token ::\n      //   - Punctuator\n      //   - Name\n      //   - IntValue\n      //   - FloatValue\n      //   - StringValue\n      //\n      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }\n\n      case 0x0021:\n        // !\n        return createToken(lexer, TokenKind.BANG, position, position + 1);\n\n      case 0x0024:\n        // $\n        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);\n\n      case 0x0026:\n        // &\n        return createToken(lexer, TokenKind.AMP, position, position + 1);\n\n      case 0x0028:\n        // (\n        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);\n\n      case 0x0029:\n        // )\n        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);\n\n      case 0x002e:\n        // .\n        if (\n          body.charCodeAt(position + 1) === 0x002e &&\n          body.charCodeAt(position + 2) === 0x002e\n        ) {\n          return createToken(lexer, TokenKind.SPREAD, position, position + 3);\n        }\n\n        break;\n\n      case 0x003a:\n        // :\n        return createToken(lexer, TokenKind.COLON, position, position + 1);\n\n      case 0x003d:\n        // =\n        return createToken(lexer, TokenKind.EQUALS, position, position + 1);\n\n      case 0x0040:\n        // @\n        return createToken(lexer, TokenKind.AT, position, position + 1);\n\n      case 0x005b:\n        // [\n        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);\n\n      case 0x005d:\n        // ]\n        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);\n\n      case 0x007b:\n        // {\n        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);\n\n      case 0x007c:\n        // |\n        return createToken(lexer, TokenKind.PIPE, position, position + 1);\n\n      case 0x007d:\n        // }\n        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);\n      // StringValue\n\n      case 0x0022:\n        // \"\n        if (\n          body.charCodeAt(position + 1) === 0x0022 &&\n          body.charCodeAt(position + 2) === 0x0022\n        ) {\n          return readBlockString(lexer, position);\n        }\n\n        return readString(lexer, position);\n    } // IntValue | FloatValue (Digit | -)\n\n    if (isDigit(code) || code === 0x002d) {\n      return readNumber(lexer, position, code);\n    } // Name\n\n    if (isNameStart(code)) {\n      return readName(lexer, position);\n    }\n\n    throw syntaxError(\n      lexer.source,\n      position,\n      code === 0x0027\n        ? 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?'\n        : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position)\n        ? `Unexpected character: ${printCodePointAt(lexer, position)}.`\n        : `Invalid character: ${printCodePointAt(lexer, position)}.`,\n    );\n  }\n\n  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);\n}\n/**\n * Reads a comment token from the source file.\n *\n * ```\n * Comment :: # CommentChar* [lookahead != CommentChar]\n *\n * CommentChar :: SourceCharacter but not LineTerminator\n * ```\n */\n\nfunction readComment(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.COMMENT,\n    start,\n    position,\n    body.slice(start + 1, position),\n  );\n}\n/**\n * Reads a number token from the source file, either a FloatValue or an IntValue\n * depending on whether a FractionalPart or ExponentPart is encountered.\n *\n * ```\n * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]\n *\n * IntegerPart ::\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit Digit*\n *\n * NegativeSign :: -\n *\n * NonZeroDigit :: Digit but not `0`\n *\n * FloatValue ::\n *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *\n * FractionalPart :: . Digit+\n *\n * ExponentPart :: ExponentIndicator Sign? Digit+\n *\n * ExponentIndicator :: one of `e` `E`\n *\n * Sign :: one of + -\n * ```\n */\n\nfunction readNumber(lexer, start, firstCode) {\n  const body = lexer.source.body;\n  let position = start;\n  let code = firstCode;\n  let isFloat = false; // NegativeSign (-)\n\n  if (code === 0x002d) {\n    code = body.charCodeAt(++position);\n  } // Zero (0)\n\n  if (code === 0x0030) {\n    code = body.charCodeAt(++position);\n\n    if (isDigit(code)) {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid number, unexpected digit after 0: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  } else {\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Full stop (.)\n\n  if (code === 0x002e) {\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // E e\n\n  if (code === 0x0045 || code === 0x0065) {\n    isFloat = true;\n    code = body.charCodeAt(++position); // + -\n\n    if (code === 0x002b || code === 0x002d) {\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n  if (code === 0x002e || isNameStart(code)) {\n    throw syntaxError(\n      lexer.source,\n      position,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        position,\n      )}.`,\n    );\n  }\n\n  return createToken(\n    lexer,\n    isFloat ? TokenKind.FLOAT : TokenKind.INT,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n/**\n * Returns the new position in the source after reading one or more digits.\n */\n\nfunction readDigits(lexer, start, firstCode) {\n  if (!isDigit(firstCode)) {\n    throw syntaxError(\n      lexer.source,\n      start,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        start,\n      )}.`,\n    );\n  }\n\n  const body = lexer.source.body;\n  let position = start + 1; // +1 to skip first firstCode\n\n  while (isDigit(body.charCodeAt(position))) {\n    ++position;\n  }\n\n  return position;\n}\n/**\n * Reads a single-quote string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"` [lookahead != `\"`]\n *   - `\"` StringCharacter+ `\"`\n *\n * StringCharacter ::\n *   - SourceCharacter but not `\"` or `\\` or LineTerminator\n *   - `\\u` EscapedUnicode\n *   - `\\` EscapedCharacter\n *\n * EscapedUnicode ::\n *   - `{` HexDigit+ `}`\n *   - HexDigit HexDigit HexDigit HexDigit\n *\n * EscapedCharacter :: one of `\"` `\\` `/` `b` `f` `n` `r` `t`\n * ```\n */\n\nfunction readString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n  let chunkStart = position;\n  let value = '';\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Quote (\")\n\n    if (code === 0x0022) {\n      value += body.slice(chunkStart, position);\n      return createToken(lexer, TokenKind.STRING, start, position + 1, value);\n    } // Escape Sequence (\\)\n\n    if (code === 0x005c) {\n      value += body.slice(chunkStart, position);\n      const escape =\n        body.charCodeAt(position + 1) === 0x0075 // u\n          ? body.charCodeAt(position + 2) === 0x007b // {\n            ? readEscapedUnicodeVariableWidth(lexer, position)\n            : readEscapedUnicodeFixedWidth(lexer, position)\n          : readEscapedCharacter(lexer, position);\n      value += escape.value;\n      position += escape.size;\n      chunkStart = position;\n      continue;\n    } // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n} // The string value and lexed size of an escape sequence.\n\nfunction readEscapedUnicodeVariableWidth(lexer, position) {\n  const body = lexer.source.body;\n  let point = 0;\n  let size = 3; // Cannot be larger than 12 chars (\\u{00000000}).\n\n  while (size < 12) {\n    const code = body.charCodeAt(position + size++); // Closing Brace (})\n\n    if (code === 0x007d) {\n      // Must be at least 5 chars (\\u{0}) and encode a Unicode scalar value.\n      if (size < 5 || !isUnicodeScalarValue(point)) {\n        break;\n      }\n\n      return {\n        value: String.fromCodePoint(point),\n        size,\n      };\n    } // Append this hex digit to the code point.\n\n    point = (point << 4) | readHexDigit(code);\n\n    if (point < 0) {\n      break;\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(\n      position,\n      position + size,\n    )}\".`,\n  );\n}\n\nfunction readEscapedUnicodeFixedWidth(lexer, position) {\n  const body = lexer.source.body;\n  const code = read16BitHexCode(body, position + 2);\n\n  if (isUnicodeScalarValue(code)) {\n    return {\n      value: String.fromCodePoint(code),\n      size: 6,\n    };\n  } // GraphQL allows JSON-style surrogate pair escape sequences, but only when\n  // a valid pair is formed.\n\n  if (isLeadingSurrogate(code)) {\n    // \\u\n    if (\n      body.charCodeAt(position + 6) === 0x005c &&\n      body.charCodeAt(position + 7) === 0x0075\n    ) {\n      const trailingCode = read16BitHexCode(body, position + 8);\n\n      if (isTrailingSurrogate(trailingCode)) {\n        // JavaScript defines strings as a sequence of UTF-16 code units and\n        // encodes Unicode code points above U+FFFF using a surrogate pair of\n        // code units. Since this is a surrogate pair escape sequence, just\n        // include both codes into the JavaScript string value. Had JavaScript\n        // not been internally based on UTF-16, then this surrogate pair would\n        // be decoded to retrieve the supplementary code point.\n        return {\n          value: String.fromCodePoint(code, trailingCode),\n          size: 12,\n        };\n      }\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`,\n  );\n}\n/**\n * Reads four hexadecimal characters and returns the positive integer that 16bit\n * hexadecimal string represents. For example, \"000f\" will return 15, and \"dead\"\n * will return 57005.\n *\n * Returns a negative number if any char was not a valid hexadecimal digit.\n */\n\nfunction read16BitHexCode(body, position) {\n  // readHexDigit() returns -1 on error. ORing a negative value with any other\n  // value always produces a negative value.\n  return (\n    (readHexDigit(body.charCodeAt(position)) << 12) |\n    (readHexDigit(body.charCodeAt(position + 1)) << 8) |\n    (readHexDigit(body.charCodeAt(position + 2)) << 4) |\n    readHexDigit(body.charCodeAt(position + 3))\n  );\n}\n/**\n * Reads a hexadecimal character and returns its positive integer value (0-15).\n *\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 if the provided character code was not a valid hexadecimal digit.\n *\n * HexDigit :: one of\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n *   - `A` `B` `C` `D` `E` `F`\n *   - `a` `b` `c` `d` `e` `f`\n */\n\nfunction readHexDigit(code) {\n  return code >= 0x0030 && code <= 0x0039 // 0-9\n    ? code - 0x0030\n    : code >= 0x0041 && code <= 0x0046 // A-F\n    ? code - 0x0037\n    : code >= 0x0061 && code <= 0x0066 // a-f\n    ? code - 0x0057\n    : -1;\n}\n/**\n * | Escaped Character | Code Point | Character Name               |\n * | ----------------- | ---------- | ---------------------------- |\n * | `\"`               | U+0022     | double quote                 |\n * | `\\`               | U+005C     | reverse solidus (back slash) |\n * | `/`               | U+002F     | solidus (forward slash)      |\n * | `b`               | U+0008     | backspace                    |\n * | `f`               | U+000C     | form feed                    |\n * | `n`               | U+000A     | line feed (new line)         |\n * | `r`               | U+000D     | carriage return              |\n * | `t`               | U+0009     | horizontal tab               |\n */\n\nfunction readEscapedCharacter(lexer, position) {\n  const body = lexer.source.body;\n  const code = body.charCodeAt(position + 1);\n\n  switch (code) {\n    case 0x0022:\n      // \"\n      return {\n        value: '\\u0022',\n        size: 2,\n      };\n\n    case 0x005c:\n      // \\\n      return {\n        value: '\\u005c',\n        size: 2,\n      };\n\n    case 0x002f:\n      // /\n      return {\n        value: '\\u002f',\n        size: 2,\n      };\n\n    case 0x0062:\n      // b\n      return {\n        value: '\\u0008',\n        size: 2,\n      };\n\n    case 0x0066:\n      // f\n      return {\n        value: '\\u000c',\n        size: 2,\n      };\n\n    case 0x006e:\n      // n\n      return {\n        value: '\\u000a',\n        size: 2,\n      };\n\n    case 0x0072:\n      // r\n      return {\n        value: '\\u000d',\n        size: 2,\n      };\n\n    case 0x0074:\n      // t\n      return {\n        value: '\\u0009',\n        size: 2,\n      };\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid character escape sequence: \"${body.slice(\n      position,\n      position + 2,\n    )}\".`,\n  );\n}\n/**\n * Reads a block string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"\"` BlockStringCharacter* `\"\"\"`\n *\n * BlockStringCharacter ::\n *   - SourceCharacter but not `\"\"\"` or `\\\"\"\"`\n *   - `\\\"\"\"`\n * ```\n */\n\nfunction readBlockString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let lineStart = lexer.lineStart;\n  let position = start + 3;\n  let chunkStart = position;\n  let currentLine = '';\n  const blockLines = [];\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Triple-Quote (\"\"\")\n\n    if (\n      code === 0x0022 &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n      const token = createToken(\n        lexer,\n        TokenKind.BLOCK_STRING,\n        start,\n        position + 3, // Return a string of the lines joined with U+000A.\n        dedentBlockStringLines(blockLines).join('\\n'),\n      );\n      lexer.line += blockLines.length - 1;\n      lexer.lineStart = lineStart;\n      return token;\n    } // Escaped Triple-Quote (\\\"\"\")\n\n    if (\n      code === 0x005c &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022 &&\n      body.charCodeAt(position + 3) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      chunkStart = position + 1; // skip only slash\n\n      position += 4;\n      continue;\n    } // LineTerminator\n\n    if (code === 0x000a || code === 0x000d) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n\n      if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      currentLine = '';\n      chunkStart = position;\n      lineStart = position;\n      continue;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * ```\n * Name ::\n *   - NameStart NameContinue* [lookahead != NameContinue]\n * ```\n */\n\nfunction readName(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    if (isNameContinue(code)) {\n      ++position;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.NAME,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nexport function parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport class Parser {\n  constructor(source, options = {}) {\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n    this._tokenCounter = 0;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node(token, {\n      kind: Kind.NAME,\n      value: token.value,\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(\n        TokenKind.SOF,\n        this.parseDefinition,\n        TokenKind.EOF,\n      ),\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw syntaxError(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(\n        TokenKind.BRACE_L,\n        this.parseSelection,\n        TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (this._options.allowLegacyFragmentVariables === true) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.INT,\n          value: token.value,\n        });\n\n      case TokenKind.FLOAT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.FLOAT,\n          value: token.value,\n        });\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this.advanceLexer();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: true,\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: false,\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: Kind.NULL,\n            });\n\n          default:\n            return this.node(token, {\n              kind: Kind.ENUM,\n              value: token.value,\n            });\n        }\n\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n    this.advanceLexer();\n    return this.node(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n    return this.node(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS)\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw syntaxError(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    if (this._options.noLocation !== true) {\n      node.loc = new Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return token;\n    }\n\n    throw syntaxError(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n    } else {\n      throw syntaxError(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token =\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n\n  advanceLexer() {\n    const { maxTokens } = this._options;\n\n    const token = this._lexer.advance();\n\n    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {\n      ++this._tokenCounter;\n\n      if (this._tokenCounter > maxTokens) {\n        throw syntaxError(\n          this._lexer.source,\n          token.start,\n          `Document contains more that ${maxTokens} tokens. Parsing aborted.`,\n        );\n      }\n    }\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}\n","import { parse } from 'graphql';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  Location,\n} from 'graphql/language/ast';\n\n// A map docString -> graphql document\nconst docCache = new Map<string, DocumentNode>();\n\n// A map fragmentName -> [normalized source]\nconst fragmentSourceMap = new Map<string, Set<string>>();\n\nlet printFragmentWarnings = true;\nlet experimentalFragmentVariables = false;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string: string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\nfunction cacheKeyFromLoc(loc: Location) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nfunction processFragments(ast: DocumentNode) {\n  const seenKeys = new Set<string>();\n  const definitions: DefinitionNode[] = [];\n\n  ast.definitions.forEach(fragmentDefinition => {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc!);\n\n      // We know something about this fragment\n      let sourceKeySet = fragmentSourceMap.get(fragmentName)!;\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n      }\n\n      sourceKeySet.add(sourceKey);\n\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n\n  return {\n    ...ast,\n    definitions,\n  };\n}\n\nfunction stripLoc(doc: DocumentNode) {\n  const workSet = new Set<Record<string, any>>(doc.definitions);\n\n  workSet.forEach(node => {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(key => {\n      const value = node[key];\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n\n  const loc = doc.loc as Record<string, any>;\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n\n  return doc;\n}\n\nfunction parseDocument(source: string) {\n  var cacheKey = normalize(source);\n  if (!docCache.has(cacheKey)) {\n    const parsed = parse(source, {\n      experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables,\n    } as any);\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n    docCache.set(\n      cacheKey,\n      // check that all \"new\" fragments inside the documents are consistent with\n      // existing fragments of the same name\n      stripLoc(processFragments(parsed)),\n    );\n  }\n  return docCache.get(cacheKey)!;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nexport function gql(\n  literals: string | readonly string[],\n  ...args: any[]\n) {\n\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n\n  let result = literals[0];\n\n  args.forEach((arg, i) => {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n    result += literals[i + 1];\n  });\n\n  return parseDocument(result);\n}\n\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\n\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\nconst extras = {\n  gql,\n  resetCaches,\n  disableFragmentWarnings,\n  enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables,\n};\n\nexport namespace gql {\n  export const {\n    gql,\n    resetCaches,\n    disableFragmentWarnings,\n    enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables,\n  } = extras;\n}\n\ngql.default = gql;\n\nexport default gql;\n","import { invariant } from '../../utilities/globals';\nimport { useContext } from 'react';\nimport { ApolloClient } from '../../core';\nimport { getApolloContext } from '../context';\n\nexport function useApolloClient(\n  override?: ApolloClient<object>,\n): ApolloClient<object> {\n  const context = useContext(getApolloContext());\n  const client = override || context.client;\n  invariant(\n    !!client,\n    'Could not find \"client\" in the context or passed in as an option. ' +\n    'Wrap the root component in an <ApolloProvider>, or pass an ApolloClient ' +\n    'instance in via options.',\n  );\n\n  return client;\n}\n","import { useCallback, useEffect, useRef, useState } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport {\n  MutationFunctionOptions,\n  MutationHookOptions,\n  MutationResult,\n  MutationTuple,\n} from '../types/types';\n\nimport {\n  ApolloCache,\n  DefaultContext,\n  mergeOptions,\n  OperationVariables,\n} from '../../core';\nimport { equal } from '@wry/equality';\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { ApolloError } from '../../errors';\nimport { useApolloClient } from './useApolloClient';\n\nexport function useMutation<\n  TData = any,\n  TVariables = OperationVariables,\n  TContext = DefaultContext,\n  TCache extends ApolloCache<any> = ApolloCache<any>,\n>(\n  mutation: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: MutationHookOptions<TData, TVariables, TContext, TCache>,\n): MutationTuple<TData, TVariables, TContext, TCache> {\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(mutation, DocumentType.Mutation);\n  const [result, setResult] = useState<Omit<MutationResult, 'reset'>>({\n    called: false,\n    loading: false,\n    client,\n  });\n\n  const ref = useRef({\n    result,\n    mutationId: 0,\n    isMounted: true,\n    client,\n    mutation,\n    options,\n  });\n\n  // TODO: Trying to assign these in a useEffect or useLayoutEffect breaks\n  // higher-order components.\n  {\n    Object.assign(ref.current, { client, options, mutation });\n  }\n\n  const execute = useCallback((\n    executeOptions: MutationFunctionOptions<\n      TData,\n      TVariables,\n      TContext,\n      TCache\n    > = {}\n  ) => {\n    const {options, mutation} = ref.current;\n    const baseOptions = { ...options, mutation };\n    const client = executeOptions.client || ref.current.client;\n\n    if (!ref.current.result.loading && !baseOptions.ignoreResults && ref.current.isMounted) {\n      setResult(ref.current.result = {\n        loading: true,\n        error: void 0,\n        data: void 0,\n        called: true,\n        client,\n      });\n    }\n\n    const mutationId = ++ref.current.mutationId;\n    const clientOptions = mergeOptions(\n      baseOptions,\n      executeOptions as any,\n    );\n\n    return client.mutate(clientOptions).then((response) => {\n      const { data, errors } = response;\n      const error =\n        errors && errors.length > 0\n          ? new ApolloError({ graphQLErrors: errors })\n          : void 0;\n\n      if (\n        mutationId === ref.current.mutationId &&\n        !clientOptions.ignoreResults\n      ) {\n        const result = {\n          called: true,\n          loading: false,\n          data,\n          error,\n          client,\n        };\n\n        if (ref.current.isMounted && !equal(ref.current.result, result)) {\n          setResult(ref.current.result = result);\n        }\n      }\n\n      const onCompleted = executeOptions.onCompleted || ref.current.options?.onCompleted\n      onCompleted?.(response.data!, clientOptions);\n\n      return response;\n    }).catch((error) => {\n      if (\n        mutationId === ref.current.mutationId &&\n        ref.current.isMounted\n      ) {\n        const result = {\n          loading: false,\n          error,\n          data: void 0,\n          called: true,\n          client,\n        };\n\n        if (!equal(ref.current.result, result)) {\n          setResult(ref.current.result = result);\n        }\n      }\n\n      const onError = executeOptions.onError || ref.current.options?.onError\n\n      if (onError) {\n        onError(error, clientOptions);\n\n        // TODO(brian): why are we returning this here???\n        return { data: void 0, errors: error };\n      }\n\n      throw error;\n    });\n  }, []);\n\n  const reset = useCallback(() => {\n    if (ref.current.isMounted) {\n      setResult({ called: false, loading: false, client });\n    }\n  }, []);\n\n  useEffect(() => {\n    ref.current.isMounted = true;\n\n    return () => {\n      ref.current.isMounted = false;\n    };\n  }, []);\n\n  return [execute, { reset, ...result }];\n}\n","import { invariant } from '../../utilities/globals';\nimport * as React from 'react';\n\nimport { canUseLayoutEffect } from '../../utilities';\n\nlet didWarnUncachedGetSnapshot = false;\n\ntype RealUseSESHookType =\n  // This import depends only on the @types/use-sync-external-store package, not\n  // the actual use-sync-external-store package, which is not installed. It\n  // might be nice to get this type from React 18, but it still needs to work\n  // when only React 17 or earlier is installed.\n  typeof import(\"use-sync-external-store\").useSyncExternalStore;\n\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nconst uSESKey = \"useSyncExternalStore\" as keyof typeof React;\nconst realHook = React[uSESKey] as RealUseSESHookType | undefined;\n\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport const useSyncExternalStore: RealUseSESHookType = realHook || ((\n  subscribe,\n  getSnapshot,\n  getServerSnapshot,\n) => {\n  // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n  const value = getSnapshot();\n  if (\n    // DEVIATION: Using our own __DEV__ polyfill (from ../../utilities/globals).\n    __DEV__ &&\n    !didWarnUncachedGetSnapshot &&\n    // DEVIATION: Not using Object.is because we know our snapshots will never\n    // be exotic primitive values like NaN, which is !== itself.\n    value !== getSnapshot()\n  ) {\n    didWarnUncachedGetSnapshot = true;\n    // DEVIATION: Using invariant.error instead of console.error directly.\n    invariant.error(\n      'The result of getSnapshot should be cached to avoid an infinite loop',\n    );\n  }\n\n  // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n  const [{inst}, forceUpdate] = React.useState({inst: {value, getSnapshot}});\n\n  // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n  if (canUseLayoutEffect) {\n    // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n    // which may seem like a conditional hook, but this code ends up behaving\n    // unconditionally (one way or the other) because canUseLayoutEffect is\n    // constant.\n    React.useLayoutEffect(() => {\n      Object.assign(inst, { value, getSnapshot });\n      // Whenever getSnapshot or subscribe changes, we need to check in the\n      // commit phase if there was an interleaved mutation. In concurrent mode\n      // this can happen all the time, but even in synchronous mode, an earlier\n      // effect may have mutated the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({inst});\n      }\n    }, [subscribe, value, getSnapshot]);\n  } else {\n    Object.assign(inst, { value, getSnapshot });\n  }\n\n  React.useEffect(() => {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({inst});\n    }\n\n    // Subscribe to the store and return a clean-up function.\n    return subscribe(function handleStoreChange() {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({inst});\n      }\n    });\n  }, [subscribe]);\n\n  return value;\n});\n\nfunction checkIfSnapshotChanged<Snapshot>({\n  value,\n  getSnapshot,\n}: {\n  value: Snapshot;\n  getSnapshot: () => Snapshot;\n}): boolean {\n  try {\n    return value !== getSnapshot();\n  } catch {\n    return true;\n  }\n}\n","import { invariant } from '../../utilities/globals';\n\nimport {\n  useCallback,\n  useContext,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { useSyncExternalStore } from './useSyncExternalStore';\nimport { equal } from '@wry/equality';\n\nimport { mergeOptions, OperationVariables, WatchQueryFetchPolicy } from '../../core';\nimport { ApolloContextValue, getApolloContext } from '../context';\nimport { ApolloError } from '../../errors';\nimport {\n  ApolloClient,\n  ApolloQueryResult,\n  NetworkStatus,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from '../../core';\nimport {\n  QueryHookOptions,\n  QueryResult,\n  ObservableQueryFields,\n} from '../types/types';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { useApolloClient } from './useApolloClient';\nimport { canUseWeakMap, compact, isNonEmptyArray, maybeDeepFreeze } from '../../utilities';\n\nconst {\n  prototype: {\n    hasOwnProperty,\n  },\n} = Object;\n\nexport function useQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<TData, TVariables> = Object.create(null),\n): QueryResult<TData, TVariables> {\n  return useInternalState(\n    useApolloClient(options.client),\n    query,\n  ).useQuery(options);\n}\n\nexport function useInternalState<TData, TVariables extends OperationVariables>(\n  client: ApolloClient<any>,\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n): InternalState<TData, TVariables> {\n  const stateRef = useRef<InternalState<TData, TVariables>>();\n  if (\n    !stateRef.current ||\n    client !== stateRef.current.client ||\n    query !== stateRef.current.query\n  ) {\n    stateRef.current = new InternalState(client, query, stateRef.current);\n  }\n  const state = stateRef.current;\n\n  // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate is the\n  // only way we trigger React component updates (no other useState calls within\n  // the InternalState class).\n  const [_tick, setTick] = useState(0);\n  state.forceUpdate = () => {\n    setTick(tick => tick + 1);\n  };\n\n  return state;\n}\n\nclass InternalState<TData, TVariables extends OperationVariables> {\n  constructor(\n    public readonly client: ReturnType<typeof useApolloClient>,\n    public readonly query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    previous?: InternalState<TData, TVariables>,\n  ) {\n    verifyDocumentType(query, DocumentType.Query);\n\n    // Reuse previousData from previous InternalState (if any) to provide\n    // continuity of previousData even if/when the query or client changes.\n    const previousResult = previous && previous.result;\n    const previousData = previousResult && previousResult.data;\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n\n  forceUpdate() {\n    // Replaced (in useInternalState) with a method that triggers an update.\n    invariant.warn(\"Calling default no-op implementation of InternalState#forceUpdate\");\n  }\n\n  executeQuery(options: QueryHookOptions<TData, TVariables>) {\n    if (options.query) {\n      Object.assign(this, { query: options.query })\n    }\n\n    this.watchQueryOptions = this.createWatchQueryOptions(\n      this.queryHookOptions = options,\n    );\n\n    const concast = this.observable.reobserveAsConcast(\n      this.getObsQueryOptions()\n    );\n\n    // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n    this.previousData = this.result?.data || this.previousData;\n    this.result = void 0;\n    this.forceUpdate();\n\n    return new Promise<QueryResult<TData, TVariables>>((resolve) => {\n      let result: ApolloQueryResult<TData>;\n\n      // Subscribe to the concast independently of the ObservableQuery in case \n      // the component gets unmounted before the promise resolves. This prevents\n      // the concast from terminating early and resolving with `undefined` when\n      // there are no more subscribers for the concast.\n      concast.subscribe({\n        next: (value) => {\n          result = value;\n        },\n        error: () => {\n          resolve(this.toQueryResult(this.observable.getCurrentResult()));\n        },\n        complete: () => {\n          resolve(this.toQueryResult(result));\n        }\n      });\n    });\n  }\n\n  // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n  useQuery(options: QueryHookOptions<TData, TVariables>) {\n    // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n    this.renderPromises = useContext(getApolloContext()).renderPromises;\n\n    this.useOptions(options);\n\n    const obsQuery = this.useObservableQuery();\n\n    const result = useSyncExternalStore(\n      useCallback(() => {\n        if (this.renderPromises) {\n          return () => {};\n        }\n\n        const onNext = () => {\n          const previousResult = this.result;\n          // We use `getCurrentResult()` instead of the onNext argument because\n          // the values differ slightly. Specifically, loading results will have\n          // an empty object for data instead of `undefined` for some reason.\n          const result = obsQuery.getCurrentResult();\n          // Make sure we're not attempting to re-render similar results\n          if (\n            previousResult &&\n            previousResult.loading === result.loading &&\n            previousResult.networkStatus === result.networkStatus &&\n            equal(previousResult.data, result.data)\n          ) {\n            return;\n          }\n\n          this.setResult(result);\n        };\n\n        const onError = (error: Error) => {\n          const last = obsQuery[\"last\"];\n          subscription.unsubscribe();\n          // Unfortunately, if `lastError` is set in the current\n          // `observableQuery` when the subscription is re-created,\n          // the subscription will immediately receive the error, which will\n          // cause it to terminate again. To avoid this, we first clear\n          // the last error/result from the `observableQuery` before re-starting\n          // the subscription, and restore it afterwards (so the subscription\n          // has a chance to stay open).\n          try {\n            obsQuery.resetLastResults();\n            subscription = obsQuery.subscribe(onNext, onError);\n          } finally {\n            obsQuery[\"last\"] = last;\n          }\n\n          if (!hasOwnProperty.call(error, 'graphQLErrors')) {\n            // The error is not a GraphQL error\n            throw error;\n          }\n\n          const previousResult = this.result;\n          if (\n            !previousResult ||\n            (previousResult && previousResult.loading) ||\n            !equal(error, previousResult.error)\n          ) {\n            this.setResult({\n              data: (previousResult && previousResult.data) as TData,\n              error: error as ApolloError,\n              loading: false,\n              networkStatus: NetworkStatus.error,\n            });\n          }\n        };\n\n        let subscription = obsQuery.subscribe(onNext, onError);\n\n        // Do the \"unsubscribe\" with a short delay.\n        // This way, an existing subscription can be reused without an additional\n        // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery \n        // happen in very fast succession.\n        return () => setTimeout(() => subscription.unsubscribe());\n      }, [\n        // We memoize the subscribe function using useCallback and the following\n        // dependency keys, because the subscribe function reference is all that\n        // useSyncExternalStore uses internally as a dependency key for the\n        // useEffect ultimately responsible for the subscription, so we are\n        // effectively passing this dependency array to that useEffect buried\n        // inside useSyncExternalStore, as desired.\n        obsQuery,\n        this.renderPromises,\n        this.client.disableNetworkFetches,\n      ]),\n\n      () => this.getCurrentResult(),\n      () => this.getCurrentResult(),\n    );\n\n    // TODO Remove this method when we remove support for options.partialRefetch.\n    this.unsafeHandlePartialRefetch(result);\n\n    return this.toQueryResult(result);\n  }\n\n  // These members (except for renderPromises) are all populated by the\n  // useOptions method, which is called unconditionally at the beginning of the\n  // useQuery method, so we can safely use these members in other/later methods\n  // without worrying they might be uninitialized.\n  private renderPromises: ApolloContextValue[\"renderPromises\"];\n  private queryHookOptions: QueryHookOptions<TData, TVariables>;\n  private watchQueryOptions: WatchQueryOptions<TVariables, TData>;\n\n  private useOptions(\n    options: QueryHookOptions<TData, TVariables>,\n  ) {\n    const watchQueryOptions = this.createWatchQueryOptions(\n      this.queryHookOptions = options,\n    );\n\n    // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n    const currentWatchQueryOptions = this.watchQueryOptions;\n\n    if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n      this.watchQueryOptions = watchQueryOptions;\n\n      if (currentWatchQueryOptions && this.observable) {\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        this.observable.reobserve(this.getObsQueryOptions());\n\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        this.previousData = this.result?.data || this.previousData;\n        this.result = void 0;\n      }\n    }\n\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if (\n      (this.renderPromises || this.client.disableNetworkFetches) &&\n      this.queryHookOptions.ssr === false &&\n      !this.queryHookOptions.skip\n    ) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (\n      this.queryHookOptions.skip ||\n      this.watchQueryOptions.fetchPolicy === 'standby'\n    ) {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (\n      this.result === this.ssrDisabledResult ||\n      this.result === this.skipStandbyResult\n    ) {\n      this.result = void 0;\n    }\n  }\n\n  private getObsQueryOptions(): WatchQueryOptions<TVariables, TData> {\n    const toMerge: Array<\n      Partial<WatchQueryOptions<TVariables, TData>>\n    > = [];\n\n    const globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    }\n\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(compact(\n      this.observable && this.observable.options,\n      this.watchQueryOptions,\n    ));\n\n    return toMerge.reduce(\n      mergeOptions\n    ) as WatchQueryOptions<TVariables, TData>;\n  }\n\n  private ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n  });\n\n  private skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n  });\n\n  // A function to massage options before passing them to ObservableQuery.\n  private createWatchQueryOptions({\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    ...otherOptions\n  }: QueryHookOptions<TData, TVariables> = {}): WatchQueryOptions<TVariables, TData> {\n    // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n    const watchQueryOptions: WatchQueryOptions<TVariables, TData> =\n      Object.assign(otherOptions, { query: this.query });\n\n    if (\n      this.renderPromises &&\n      (\n        watchQueryOptions.fetchPolicy === 'network-only' ||\n        watchQueryOptions.fetchPolicy === 'cache-and-network'\n      )\n    ) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = 'cache-first';\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {} as TVariables;\n    }\n\n    if (skip) {\n      const {\n        fetchPolicy = this.getDefaultFetchPolicy(),\n        initialFetchPolicy = fetchPolicy,\n      } = watchQueryOptions;\n\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy,\n        fetchPolicy: 'standby',\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy =\n        this.observable?.options.initialFetchPolicy ||\n        this.getDefaultFetchPolicy();\n    }\n\n    return watchQueryOptions;\n  }\n\n  getDefaultFetchPolicy(): WatchQueryFetchPolicy {\n    return (\n      this.queryHookOptions.defaultOptions?.fetchPolicy ||\n      this.client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\"\n    );\n  }\n\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  private onCompleted(data: TData) {}\n  private onError(error: ApolloError) {}\n\n  private observable: ObservableQuery<TData, TVariables>;\n  private obsQueryFields: Omit<\n    ObservableQueryFields<TData, TVariables>,\n    \"variables\"\n  >;\n\n  private useObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    const obsQuery = this.observable =\n      this.renderPromises\n        && this.renderPromises.getSSRObservable(this.watchQueryOptions)\n        || this.observable // Reuse this.observable if possible (and not SSR)\n        || this.client.watchQuery(this.getObsQueryOptions());\n\n    this.obsQueryFields = useMemo(() => ({\n      refetch: obsQuery.refetch.bind(obsQuery),\n      reobserve: obsQuery.reobserve.bind(obsQuery),\n      fetchMore: obsQuery.fetchMore.bind(obsQuery),\n      updateQuery: obsQuery.updateQuery.bind(obsQuery),\n      startPolling: obsQuery.startPolling.bind(obsQuery),\n      stopPolling: obsQuery.stopPolling.bind(obsQuery),\n      subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n    }), [obsQuery]);\n\n    const ssrAllowed = !(\n      this.queryHookOptions.ssr === false ||\n      this.queryHookOptions.skip\n    );\n\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n\n      if (obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  }\n\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  private result: undefined | ApolloQueryResult<TData>;\n  private previousData: undefined | TData;\n\n  private setResult(nextResult: ApolloQueryResult<TData>) {\n    const previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult);\n  }\n\n  private handleErrorOrCompleted(result: ApolloQueryResult<TData>) {\n    if (!result.loading) {\n      const error = this.toApolloError(result);\n\n      // wait a tick in case we are in the middle of rendering a component\n      Promise.resolve().then(() => {\n        if (error) {\n          this.onError(error);\n        } else if (result.data) {\n          this.onCompleted(result.data);\n        }\n      }).catch(error => {\n        invariant.warn(error);\n      });\n    }\n  }\n\n  private toApolloError(result: ApolloQueryResult<TData>): ApolloError | undefined {\n    return isNonEmptyArray(result.errors)\n      ? new ApolloError({ graphQLErrors: result.errors })\n      : result.error\n  }\n\n  private getCurrentResult(): ApolloQueryResult<TData> {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(\n        this.result = this.observable.getCurrentResult()\n      );\n    }\n    return this.result;\n  }\n\n  // This cache allows the referential stability of this.result (as returned by\n  // getCurrentResult) to translate into referential stability of the resulting\n  // QueryResult object returned by toQueryResult.\n  private toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)<\n    ApolloQueryResult<TData>,\n    QueryResult<TData, TVariables>\n  >();\n\n  toQueryResult(\n    result: ApolloQueryResult<TData>,\n  ): QueryResult<TData, TVariables> {\n    let queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    const { data, partial, ...resultWithoutPartial } = result;\n    this.toQueryResultCache.set(result, queryResult = {\n      data, // Ensure always defined, even if result.data is missing.\n      ...resultWithoutPartial,\n      ...this.obsQueryFields,\n      client: this.client,\n      observable: this.observable,\n      variables: this.observable.variables,\n      called: !this.queryHookOptions.skip,\n      previousData: this.previousData,\n    });\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n    }\n\n    return queryResult;\n  }\n\n  private unsafeHandlePartialRefetch(result: ApolloQueryResult<TData>) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      result.partial &&\n      this.queryHookOptions.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      this.observable.options.fetchPolicy !== 'cache-only'\n    ) {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      });\n      this.observable.refetch();\n    }\n  }\n}\n","import { invariant } from '../../utilities/globals';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode\n} from 'graphql';\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nconst cache = new Map();\n\nexport function operationName(type: DocumentType) {\n  let name;\n  switch (type) {\n    case DocumentType.Query:\n      name = 'Query';\n      break;\n    case DocumentType.Mutation:\n      name = 'Mutation';\n      break;\n    case DocumentType.Subscription:\n      name = 'Subscription';\n      break;\n  }\n  return name;\n}\n\n// This parser is mostly used to safety check incoming documents.\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  const cached = cache.get(document);\n  if (cached) return cached;\n\n  let variables, type, name;\n\n  invariant(\n    !!document && !!document.kind,\n    `Argument of ${document} passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`\n  );\n\n  const fragments: DefinitionNode[] = []\n  const queries: DefinitionNode[] = []\n  const mutations: DefinitionNode[] = []\n  const subscriptions: DefinitionNode[] = []\n\n  for (const x of document.definitions) {\n    if (x.kind === 'FragmentDefinition') {\n      fragments.push(x);\n      continue\n    }\n\n    if (x.kind === 'OperationDefinition') {\n      switch (x.operation) {\n        case 'query':\n          queries.push(x);\n          break;\n        case 'mutation':\n          mutations.push(x);\n          break;\n        case 'subscription':\n          subscriptions.push(x);\n          break;\n      }\n    }\n  }\n\n  invariant(\n    !fragments.length ||\n      (queries.length || mutations.length || subscriptions.length),\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `${document} had ${queries.length} queries, ${subscriptions.length} ` +\n      `subscriptions and ${mutations.length} mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions = queries.length\n    ? queries\n    : mutations.length\n    ? mutations\n    : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    `react-apollo only supports one definition per HOC. ${document} had ` +\n      `${definitions.length} definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data'; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n\nexport function verifyDocumentType(document: DocumentNode, type: DocumentType) {\n  const operation = parser(document);\n  const requiredOperationName = operationName(type);\n  const usedOperationName = operationName(operation.type);\n  invariant(\n    operation.type === type,\n    `Running a ${requiredOperationName} requires a graphql ` +\n      `${requiredOperationName}, but a ${usedOperationName} was used instead.`\n  );\n}\n\n"],"names":["invariant","condition","message","Boolean","Error","LineRegExp","getLocation","source","position","_step","lastLineStart","line","_iterator","_createForOfIteratorHelper","body","matchAll","s","n","done","match","value","index","length","err","e","f","column","printLocation","location","printSourceLocation","start","sourceLocation","firstLineColumnOffset","locationOffset","padStart","lineIndex","lineOffset","lineNum","columnOffset","columnNum","locationStr","concat","name","lines","split","locationLine","subLineIndex","Math","floor","subLineColumnNum","subLines","i","push","slice","printPrefixedLines","_toConsumableArray","map","subLine","existingLines","filter","_ref","_ref2","_slicedToArray","undefined","padLen","max","apply","_ref3","_ref5","_ref6","prefix","join","GraphQLError","_Error","_Symbol$toStringTag","_inherits","_super","_createSuper","_this","_this$nodes","_nodeLocations$","_classCallCheck","_len","arguments","rawArgs","Array","_key","_toNormalizedOptions","args","firstArg","nodes","positions","path","originalError","extensions","toNormalizedOptions","call","undefinedIfEmpty","isArray","nodeLocations","node","loc","locations","pos","originalExtensions","Object","create","defineProperties","_assertThisInitialized","writable","enumerable","stack","defineProperty","configurable","captureStackTrace","_createClass","key","get","output","this","_step2","_iterator2","formattedError","keys","_wrapNativeSuper","Symbol","toStringTag","array","syntaxError","description","DirectiveLocation","TokenKind","Lexer","startOfFileToken","Token","lastToken","token","lineStart","lookahead","kind","next","nextToken","readNextToken","end","prev","isUnicodeScalarValue","code","isSupplementaryCodePoint","isLeadingSurrogate","charCodeAt","isTrailingSurrogate","printCodePointAt","lexer","codePointAt","char","String","fromCodePoint","toString","toUpperCase","createToken","col","bodyLength","readComment","readBlockString","readString","isDigit","readNumber","isNameStart","readName","firstCode","isFloat","readDigits","chunkStart","escape","readEscapedUnicodeVariableWidth","readEscapedUnicodeFixedWidth","readEscapedCharacter","size","point","readHexDigit","read16BitHexCode","trailingCode","currentLine","blockLines","dedentBlockStringLines","isNameContinue","Parser","options","sourceObj","isSource","Source","_lexer","_options","_tokenCounter","expectToken","Kind","definitions","many","parseDefinition","peek","parseOperationDefinition","hasDescription","peekDescription","keywordToken","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseFragmentDefinition","parseTypeSystemExtension","unexpected","operation","OperationTypeNode","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseName","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","parseVariableDefinition","variable","parseVariable","type","parseTypeReference","defaultValue","expectOptionalToken","parseConstValueLiteral","parseConstDirectives","selections","parseSelection","parseFragment","parseField","alias","nameOrAlias","parseArguments","isConst","item","parseConstArgument","parseArgument","parseValueLiteral","hasTypeCondition","expectOptionalKeyword","parseFragmentName","typeCondition","parseNamedType","expectKeyword","allowLegacyFragmentVariables","parseList","parseObject","advanceLexer","parseStringLiteral","varName","block","values","any","_this2","fields","parseObjectField","parseDirective","innerType","parseDescription","operationTypes","parseOperationTypeDefinition","interfaces","parseImplementsInterfaces","parseFieldsDefinition","delimitedMany","parseFieldDefinition","parseArgumentDefs","parseInputValueDef","types","parseUnionMemberTypes","parseEnumValuesDefinition","parseEnumValueDefinition","parseEnumValueName","getTokenDesc","parseInputFieldsDefinition","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","repeatable","parseDirectiveLocations","parseDirectiveLocation","prototype","hasOwnProperty","startToken","noLocation","Location","getTokenKindDesc","atToken","openKind","parseFn","closeKind","delimiterKind","maxTokens","advance","isPunctuatorTokenKind","docCache","Map","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","normalize","string","replace","trim","processFragments","ast","seenKeys","Set","forEach","fragmentDefinition","fragmentName","sourceKey","substring","sourceKeySet","has","console","warn","set","add","__assign","parseDocument","cacheKey","parsed","parse","doc","workSet","endToken","stripLoc","gql","literals","_i","result","arg","gql_1","extras","clear","resetCaches","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","useApolloClient","override","context","useContext","getApolloContext","client","__DEV__","useMutation","mutation","verifyDocumentType","DocumentType","_a","useState","called","loading","setResult","ref","useRef","mutationId","isMounted","assign","current","execute","useCallback","executeOptions","baseOptions","ignoreResults","error","data","clientOptions","mergeOptions","mutate","then","response","errors","ApolloError","graphQLErrors","result_1","equal","onCompleted","catch","result_2","onError","reset","useEffect","didWarnUncachedGetSnapshot","useSyncExternalStore","React","subscribe","getSnapshot","getServerSnapshot","inst","forceUpdate","canUseLayoutEffect","checkIfSnapshotChanged","_b","useQuery","query","stateRef","InternalState","state","setTick","tick","useInternalState","previous","ssrDisabledResult","maybeDeepFreeze","networkStatus","NetworkStatus","skipStandbyResult","toQueryResultCache","canUseWeakMap","WeakMap","previousResult","previousData","executeQuery","watchQueryOptions","createWatchQueryOptions","queryHookOptions","concast","observable","reobserveAsConcast","getObsQueryOptions","Promise","resolve","toQueryResult","getCurrentResult","complete","renderPromises","useOptions","obsQuery","useObservableQuery","onNext","subscription","last","unsubscribe","resetLastResults","setTimeout","disableNetworkFetches","unsafeHandlePartialRefetch","currentWatchQueryOptions","reobserve","ssr","skip","fetchPolicy","toMerge","globalDefaults","defaultOptions","watchQuery","compact","reduce","otherOptions","__rest","variables","_c","getDefaultFetchPolicy","_d","initialFetchPolicy","getSSRObservable","obsQueryFields","useMemo","refetch","bind","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","ssrAllowed","registerSSRObservable","addObservableQueryPromise","nextResult","handleErrorOrCompleted","error_1","toApolloError","isNonEmptyArray","queryResult","resultWithoutPartial","partial","partialRefetch","cache","operationName","Query","Mutation","Subscription","document","cached","fragments","queries","mutations","subscriptions","x","definition","payload","parser","requiredOperationName","usedOperationName"],"sourceRoot":""}